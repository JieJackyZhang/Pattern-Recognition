import java.io.File;
import java.util.*;

/**
 * Main-Class for launching the program.
 * @author Jacky
 */
public class FPGrowth {
	
	/**
	 * an instance of DataIO to get data information
	 */
	private DataIO dataIO;
	
	/**
	 * input file name
	 */
	private String inputFile;
	
	/**
	 * output file name
	 */
	private String outputFile;
	
	/**
	 * relative minimum support threshold
	 */
	private float minSupRatio;
	
	/**
	 * true if having changed minimum support
	 */
	public boolean isMinSupChanged;
	
	/**
	 * input stream
	 */
	public Scanner input;
	
	/**
	 * store frequent patterns to output file 
	 */
	private List<String> result = new ArrayList<String>();
	
	/**
	 * Initialize data input and output.
	 */
	private void init() {
		dataIO = new DataIO(inputFile, outputFile, minSupRatio);
		result.clear();
	}
	
	
	/**
	 * Check validity of minimum support ratio
	 * @param minSupRatio
	 * @return true if minimum support ratio is valid, false otherwise
	 */
	private boolean checkMinSupRatio(float minSupRatio) {
		if(minSupRatio >= 0 && minSupRatio <= 100)
			return true;
		else
			return false;
	}		
	
	/**
	 * User Interface when launching the program.
	 * Set input file, output file, and minimum support ratio. 
	 */
	public void set() {		
		
		
		System.out.println("Welcome to FP-Growth >>>>>>\n");
		
		System.out.print("Please enter the INPUT file name: ");		
		inputFile = input.next();
		boolean isFile = new File(inputFile).isFile();
		while(isFile == false) {
			System.out.println("The input is not a valid file!");
			System.out.print("Please enter the INPUT file name: ");		
			inputFile = input.next();
			isFile = new File(inputFile).isFile();
		}
		
		System.out.print("Please enter the RELATIVE MINIMUM SUPPORT (%), range [0-100]: ");		
		boolean isValidMinSup = false;
		try {
			minSupRatio = input.nextFloat();
			isValidMinSup = checkMinSupRatio(minSupRatio);
		} catch(InputMismatchException e) {
			isValidMinSup = false;
		}
		while(isValidMinSup == false) {
			input.nextLine();
			System.out.println("The input is not a valid number!");	
			System.out.print("Please enter the RELATIVE MINIMUM SUPPORT (%), range [0-100]: ");	
			try {
				minSupRatio = input.nextFloat();
				isValidMinSup = checkMinSupRatio(minSupRatio);
			} catch(InputMismatchException e) {
				System.out.println("Please input a number!");
				isValidMinSup = false;
			}
		}
		
		System.out.print("Please enter the OUTPUT file name: ");		
		outputFile = input.next();
		
		System.out.print("\n");				
		
		//initialize data input and output.
		init();
			
	}
	
	/**
	 * Display the frequent pattern in screen,
	 * and store it to result list.
	 * @param itemset
	 * @param support
	 */
	private void generateFP(String[] itemset, int support) {
		String res = new String();
		for(int i = 0; i < itemset.length; i++) {
			System.out.print(itemset[i] + " ");
			res += itemset[i] + " ";
		}
		System.out.println(": " + support);
		result.add(res + ": " + support);
	}	
	
	/**
	 * Handle the single path situation of the FP-tree.
	 * For each combinations of the nodes in the path, 
	 * generate the frequent patterns concatenated with given suffix.
	 * Called by method fpgrowth().
	 * @param node
	 * @param suffix  suffix of the patterns generated by this FP-tree
	 * @param suffixCount  the minimum count of nodes in suffix
	 */
	private void handleSinglePath(FPNode node, String[] suffix, int suffixCount) {
		if(node.item == null) {
			//if root
			return;
		}
		
		//generate the frequent pattern
		//create itemset = node's item concatenated with suffix
		//support = minimun support of nodes in itemset
		String[] itemset = new String[suffix.length + 1];
		itemset[0] = node.item;
		System.arraycopy(suffix, 0, itemset, 1, suffix.length);		
		int minCount = node.count < suffixCount ? node.count : suffixCount;
		generateFP(itemset, minCount);
		
		if(node.parent.item != null) {
			//if parent is not root, find all combinations recursively 
			handleSinglePath(node.parent, suffix, suffixCount);
			handleSinglePath(node.parent, itemset, minCount);
		}
	}
	
	/**
	 * Handle the multiple paths situation of the FP-tree.
	 * Called by method fpgrowth().
	 * @param tree  FP-tree
	 * @param suffix  suffix of the patterns generated by this FP-tree
	 */
	private void handleMultiplePaths(FPTree tree, String[] suffix) {
		for(int i = tree.getHeaderListLength()-1; i >= 0; i--) {
			//process each item in header list in reverse order
			
			//for each item in header list, 
			//create itemset = item concatenated with suffix
			//support = item's support in header table
			String item = tree.getItemFromHeaderList(i);
			int itemCount = tree.getSupportByItem(item);
			String[] itemset = new String[suffix.length + 1];
			itemset[0] = item;
			System.arraycopy(suffix, 0, itemset, 1, suffix.length);
			generateFP(itemset, itemCount);
			
			//***************************************************
			//construct itemset's Conditional Pattern Base
			//***************************************************
			//a sub-database consists of the set of prefix paths
			//in the FP-tree co-occurring wtih the suffix pattern
			List<List<FPNode>> prefixPaths = new ArrayList<List<FPNode>>();
			//get the first node in tree having that item
			FPNode node = tree.getNodeByItem(item);
			while(node != null) {
				//find all prefix paths by node links
				if(node.parent.item != null) {
					//if prefix path doesn't only have the root, add it to list
					List<FPNode> path = new ArrayList<FPNode>();
					path.add(node);
					FPNode parentNode = node.parent;
					while(parentNode.item != null) {
						path.add(parentNode);
						parentNode = parentNode.parent;
					}
					prefixPaths.add(path);				
				}
				//look for next prefix path
				node = node.nodelink;
			}
			
			
			//create conditional FP-tree			
			//get count of each single item in conditional FP-tree
			Map<String, Integer> newMapSingleItem = new HashMap<String, Integer>();
			for(List<FPNode> path : prefixPaths) {
				//get support of the path 
				int pathCount = path.get(0).count;
				for(int j = 1; j < path.size(); j++) {
					node = path.get(j);
					if(newMapSingleItem.get(node.item) == null) {
						//no such item, add one
						newMapSingleItem.put(node.item, pathCount);
					} else {
						//has item, increase its count by path count
						newMapSingleItem.put(node.item, newMapSingleItem.get(node.item)+pathCount); 
					}
				}
			}
			
			//***************************************************
			//construct itemset's Conditional FP-tree
			//***************************************************
			FPTree newTree = new FPTree(newMapSingleItem);
			for(List<FPNode> path : prefixPaths) {
				//add each prefix path in conditional FP-tree
				newTree.addPrefixPath(path, dataIO.getMinSupport());
			}			
			//mine conditional FP-tree recursively
			if(newTree.isEmpty() == false) {
				newTree.createHeaderList(dataIO.getMapSingleItem());
//				newTree.traverse();
				fpgrowth(newTree, itemset, itemCount);
			}													
		}
	}
	
	/**
	 * Run FP-growth algorithm.
	 * @param tree  FP-tree
	 * @param suffix  suffix of the patterns generated by this FP-tree
	 * @param suffixCount  the minimum count of nodes in suffix
	 */
	public void fpgrowth(FPTree tree, String[] suffix, int suffixCount) {
		if(tree.isEmpty())
			return;
		if(tree.hasSinglePath() == true) {
			//if single path
			//start from the last node in header list
			handleSinglePath(tree.getLastHeaderNode(), suffix, suffixCount);
		} else {
			//if multiple path
			handleMultiplePaths(tree, suffix);
		}
		
	}
	
	/**
	 * Run the FP-growth program to mine frequent patterns.
	 */
	private void run() {
		//get start time
		long startTime = System.currentTimeMillis();
		dataIO.readFile();
		//create the base FP-tree
		FPTree tree = new FPTree(dataIO.getMapSingleItem());
		dataIO.createTreeFromData(tree);
		tree.createHeaderList(dataIO.getMapSingleItem());
//		tree.traverse();

		System.out.println("Generate frequent patterns >>>");
		//init suffix = null
		String[] suffix = new String[0];
		//do FP-growth algorithm
		fpgrowth(tree, suffix, dataIO.getTransactionCount());
		//get end time
		long endTime = System.currentTimeMillis();
		//write the result into output file
		dataIO.writeFile(result);
		//display running time
		System.out.println("\nFrequent Pattern Mining is complete!");
		dataIO.printMinSup();
		System.out.println("The total number of frequent patterns: " + result.size());
		System.out.println("Running time: " + (endTime-startTime) + "ms\n");
	}
	
	/**
	 * Change minimum support ratio, and run algorithm again.
	 */
	private void changeMinSupRatio() {
		isMinSupChanged = false;
//		input.nextLine();
		System.out.print("Do you want to CHANGE min support (y/[n]): ");
		String s = input.next();
		if(s.equals("y")) {
			System.out.print("Please enter the RELATIVE MINIMUM SUPPORT (%), range [0-100]: ");		
			boolean isValidMinSup = false;
			try {
				minSupRatio = input.nextFloat();
				isValidMinSup = checkMinSupRatio(minSupRatio);
			} catch(InputMismatchException e) {
				isValidMinSup = false;
			}
			while(isValidMinSup == false) {
				input.nextLine();
				System.out.println("The input is not a valid number!");	
				System.out.print("Please enter the RELATIVE MINIMUM SUPPORT (%), range [0-100]: ");	
				try {
					minSupRatio = input.nextFloat();
					isValidMinSup = checkMinSupRatio(minSupRatio);
				} catch(InputMismatchException e) {
					System.out.println("Please input a number!");
					isValidMinSup = false;
				}
			}
			isMinSupChanged = true;
			init();
		}
		
	}

	/**
	 * Main method.
	 * Launch the program.
	 * @param args
	 */
	public static void main(String[] args) {
		FPGrowth fp = new FPGrowth();
		fp.input = new Scanner(System.in);
		fp.set();	
		fp.run();
		fp.changeMinSupRatio();
		while(fp.isMinSupChanged == true) {
			fp.run();
			fp.changeMinSupRatio();
		}
		System.out.println("Thank you for using FP-growth. Goodbye!");
		fp.input.close();
		System.exit(-1);
	}

}
